<?xml version="1.0"?>

<precice-configuration>
  <!-- format for console output of precice -->
  <log>
    <sink type="stream" output="stdout"  filter='(%Severity% >= debug) and (%Rank% = 0) and (not (%Function% = "advance"))' format="\033[0;33m%Rank% [precice]\033[0m %ColorizedSeverity%\033[0;33m%Message%\033[0m" enabled="true" />
    <!--<sink type="stream" output="stdout"  filter='%Severity% >= debug' format="\033[0;33m%Rank% [precice]\033[0m %ColorizedSeverity%\033[0;33m%Message%\033[0m" enabled="true" />-->
    <!--<sink type="file" output="debug.log" filter= "(%Severity% >= debug)" format="%Message%" enabled="true" />	-->
  </log>
  
  <!-- Data fields that are exchanged between the solvers -->
  <data:vector name="Displacement"/>
  <data:vector name="Velocity"/>
  <data:vector name="Traction"/>

  <!-- A common mesh that uses these data fields -->
  <mesh name="TendonMeshTop" dimensions="3">
    <use-data name="Displacement"/>
    <use-data name="Velocity"/>
    <use-data name="Traction"/>
  </mesh>
  
  <mesh name="TendonMeshBottomA" dimensions="3">
    <use-data name="Displacement"/>
    <use-data name="Velocity"/>
    <use-data name="Traction"/>
  </mesh>
  
  <mesh name="TendonMeshBottomB" dimensions="3">
    <use-data name="Displacement"/>
    <use-data name="Velocity"/>
    <use-data name="Traction"/>
  </mesh>

  <mesh name="MuscleMeshBottom" dimensions="3">
    <use-data name="Displacement"/>
    <use-data name="Velocity"/>
    <use-data name="Traction"/>
  </mesh>
  
  <mesh name="MuscleMeshTopA" dimensions="3">
    <use-data name="Displacement"/>
    <use-data name="Velocity"/>
    <use-data name="Traction"/>
  </mesh>

  <mesh name="MuscleMeshTopB" dimensions="3">
    <use-data name="Displacement"/>
    <use-data name="Velocity"/>
    <use-data name="Traction"/>
  </mesh>

  <!-- analogous to FSI: muscle=fluid (Dirichlet BC), tendon=structure (Neumann BC) -->

  <!-- Represents each solver using preCICE. In a coupled simulation, two participants have to be
        defined. The name of the participant has to match the name given on construction of the
        precice::Participant object used by the participant. -->
  
  <participant name="Muscle">
    <!-- Makes the named mesh available to the participant. Mesh is provided by the solver directly. -->
    <provide-mesh name="MuscleMeshBottom" />
    <provide-mesh name="MuscleMeshTopA"   />
    <provide-mesh name="MuscleMeshTopB"   />
    <receive-mesh name="TendonMeshTop"     from="Tendon-Bottom"/>
    <receive-mesh name="TendonMeshBottomA" from="Tendon-Top-A"/>
    <receive-mesh name="TendonMeshBottomB" from="Tendon-Top-B"/>
    
    <!-- Define input/output of the solver, the mesh should be the own one. -->
    <read-data  name="Displacement"  mesh="MuscleMeshBottom"/>
    <read-data  name="Velocity"      mesh="MuscleMeshBottom"/>
    <write-data name="Traction"      mesh="MuscleMeshBottom"/>
    
    <read-data  name="Displacement"  mesh="MuscleMeshTopA"/>
    <read-data  name="Velocity"      mesh="MuscleMeshTopA"/>
    <write-data name="Traction"      mesh="MuscleMeshTopA"/>
    
    <read-data  name="Displacement"  mesh="MuscleMeshTopB"/>
    <read-data  name="Velocity"      mesh="MuscleMeshTopB"/>
    <write-data name="Traction"      mesh="MuscleMeshTopB"/>
    
    <!--<export:vtk directory="precice-output" />-->
    
    <!-- map from TendonMeshTop to MuscleMeshBottom -->
    <!-- shape-parameter: 
    ./rbfShape.py 0.01 3
    Using values:
      h     = 0.01
      m     = 3
      decay = 1e-09
    Result:
      s = 151.74271293851464
    -->
    <!-- <mapping:rbf-gaussian 
      direction="read" 
      from="TendonMeshTop" 
      to="MuscleMeshBottom" 
      constraint="consistent" 
      timing="initial" 
      shape-parameter="151.74"
    />-->
    <!-- <mapping:rbf-compact-polynomial-c6
      direction="read" 
      from="TendonMeshTop" 
      to="MuscleMeshBottom" 
      constraint="consistent" 
      timing="initial" 
      support-radius="0.1"  
    />  --><!-- spacing between nodes is 0.01 -->
    <mapping:rbf 
      direction="read" 
      from="TendonMeshTop" 
      to="MuscleMeshBottom" 
      constraint="consistent">
      <basis-function:gaussian shape-parameter="91.05" />
    </mapping:rbf>

    <mapping:rbf 
      direction="read" 
      from="TendonMeshBottomA" 
      to="MuscleMeshTopA" 
      constraint="consistent">
      <basis-function:gaussian shape-parameter="91.05" />
    </mapping:rbf>

    <mapping:rbf 
      direction="read" 
      from="TendonMeshBottomB" 
      to="MuscleMeshTopB" 
      constraint="consistent">
      <basis-function:gaussian shape-parameter="91.05" />
    </mapping:rbf>

  </participant>

  <participant name="Tendon-Bottom">
    
    <!-- Makes the named mesh available to the participant. Mesh is provided by the solver directly. -->
    <provide-mesh name="TendonMeshTop"/>
    <receive-mesh name="MuscleMeshBottom" from="Muscle"/>
    <!--<export:vtk directory="precice-output" />-->
    
    <!-- Define input/output of the solver, the mesh should be the own one.  -->
    <write-data name="Displacement"  mesh="TendonMeshTop"/>
    <write-data name="Velocity"      mesh="TendonMeshTop"/>
    <read-data  name="Traction"      mesh="TendonMeshTop"/>

    <!-- rbf to map from MuscleMeshBottom to TendonMeshTop -->
    <mapping:rbf 
      direction="read" 
      from="MuscleMeshBottom" 
      to="TendonMeshTop" 
      constraint="consistent">
      <basis-function:gaussian shape-parameter="50" />
    </mapping:rbf> 
  </participant>
  
  <participant name="Tendon-Top-A">
    
    <!-- Makes the named mesh available to the participant. Mesh is provided by the solver directly. -->
    <provide-mesh name="TendonMeshBottomA"/>
    <receive-mesh name="MuscleMeshTopA" from="Muscle"/>
    <!--<export:vtk directory="precice-output" />-->
    
    <!-- Define input/output of the solver, the mesh should be the own one.  -->
    <write-data name="Displacement"  mesh="TendonMeshBottomA"/>
    <write-data name="Velocity"      mesh="TendonMeshBottomA"/>
    <read-data  name="Traction"      mesh="TendonMeshBottomA"/>

    <!-- rbf to map from MuscleMeshTop to TendonMeshBottomA -->
    <mapping:rbf 
      direction="read" 
      from="MuscleMeshTopA" 
      to="TendonMeshBottomA" 
      constraint="consistent">
      <basis-function:gaussian shape-parameter="50" />
    </mapping:rbf> 
  </participant>
  
  <participant name="Tendon-Top-B">
    
    <!-- Makes the named mesh available to the participant. Mesh is provided by the solver directly. -->
    <provide-mesh name="TendonMeshBottomB"/>
    <receive-mesh name="MuscleMeshTopB" from="Muscle"/>
    <!--<export:vtk directory="precice-output" />-->
    
    <!-- Define input/output of the solver, the mesh should be the own one.  -->
    <write-data name="Displacement"  mesh="TendonMeshBottomB"/>
    <write-data name="Velocity"      mesh="TendonMeshBottomB"/>
    <read-data  name="Traction"      mesh="TendonMeshBottomB"/>

    <!-- rbf to map from MuscleMeshTopB to TendonMeshBottomB -->
      <mapping:rbf 
      direction="read" 
      from="MuscleMeshTopB" 
      to="TendonMeshBottomB" 
      constraint="consistent">
      <basis-function:gaussian shape-parameter="50" />
    </mapping:rbf> 
  </participant>
  
  <!-- Communication method, use TCP sockets, Change network to "ib0" on SuperMUC -->
  <m2n:sockets acceptor="Muscle" connector="Tendon-Bottom" network="lo" />
  <m2n:sockets acceptor="Muscle" connector="Tendon-Top-A" network="lo" />
  <m2n:sockets acceptor="Muscle" connector="Tendon-Top-B" network="lo" />

  <!-- serial-implicit coupling scales only the displacements, which are transferred from muscle to tendon -->
  <!-- parallel-implicit coupling scales displacements and tractions -->
  <!-- see https://github.com/precice/precice/wiki/Acceleration-Configuration -->
  <coupling-scheme:multi>
    <participant name="Muscle" control="yes"/>
    <participant name="Tendon-Bottom"/>
    <participant name="Tendon-Top-A"/>
    <participant name="Tendon-Top-B"/>
    
    <max-time value="20000.0"/>           <!-- end time of the whole simulation -->
    <time-window-size value="1.0"/>   <!-- timestep width for coupling -->
    <max-iterations value="100" />
    
    <relative-convergence-measure limit="0.01" data="Displacement" mesh="TendonMeshTop" />
    <relative-convergence-measure limit="0.01" data="Displacement" mesh="TendonMeshBottomA" />
    <relative-convergence-measure limit="0.01" data="Displacement" mesh="TendonMeshBottomB" />
    <relative-convergence-measure limit="0.01" data="Velocity" mesh="TendonMeshTop" />
    <relative-convergence-measure limit="0.01" data="Velocity" mesh="TendonMeshBottomA" />
    <relative-convergence-measure limit="0.01" data="Velocity" mesh="TendonMeshBottomB" />
    <relative-convergence-measure limit="0.1" data="Traction" mesh="MuscleMeshBottom" />
    <relative-convergence-measure limit="0.1" data="Traction" mesh="MuscleMeshTopA" />
    <relative-convergence-measure limit="0.1" data="Traction" mesh="MuscleMeshTopB" />
    <!--<relative-convergence-measure limit="0.1" data="Displacement" mesh="TendonMeshTop" />-->
    <!--<relative-convergence-measure limit="0.1" data="Displacement" mesh="TendonMeshBottomA" />-->
    <!--<relative-convergence-measure limit="0.1" data="Displacement" mesh="TendonMeshBottomB" />-->
    <!--<min-iteration-convergence-measure min-iterations="{integer}" data="{string}" mesh="{string}" strict="0" suffices="0"/>-->
    
    <acceleration:IQN-ILS>
      <data name="Displacement" mesh="TendonMeshTop"/>
      <data name="Displacement" mesh="TendonMeshBottomA"/>
      <data name="Displacement" mesh="TendonMeshBottomB"/>
      <data name="Velocity" mesh="TendonMeshTop"/>
      <data name="Velocity" mesh="TendonMeshBottomA"/>
      <data name="Velocity" mesh="TendonMeshBottomB"/>
      <data name="Traction" mesh="MuscleMeshBottom"/>
      <data name="Traction" mesh="MuscleMeshTopA"/>
      <data name="Traction" mesh="MuscleMeshTopB"/>
      <preconditioner type="residual-sum"/>
      <filter type="QR2" limit="1e-3"/>
      <initial-relaxation value="0.4"/>
      <max-used-iterations value="40"/>
      <time-windows-reused value="15"/>
    </acceleration:IQN-ILS>

    <!-- <acceleration:constant>
      <relaxation value="0.7" />
    </acceleration:constant> -->

    <exchange data="Displacement"    mesh="TendonMeshTop"      from="Tendon-Bottom" to="Muscle"/>
    <exchange data="Velocity"        mesh="TendonMeshTop"      from="Tendon-Bottom" to="Muscle"/>
    <exchange data="Traction"        mesh="MuscleMeshBottom"   from="Muscle"       to="Tendon-Bottom"/>
    
    <exchange data="Displacement"    mesh="TendonMeshBottomA"  from="Tendon-Top-A"   to="Muscle"/>
    <exchange data="Velocity"        mesh="TendonMeshBottomA"  from="Tendon-Top-A"   to="Muscle"/>
    <exchange data="Traction"        mesh="MuscleMeshTopA"     from="Muscle"       to="Tendon-Top-A"/>
    
    <exchange data="Displacement"    mesh="TendonMeshBottomB"  from="Tendon-Top-B"   to="Muscle"/>
    <exchange data="Velocity"        mesh="TendonMeshBottomB"  from="Tendon-Top-B"   to="Muscle"/>
    <exchange data="Traction"        mesh="MuscleMeshTopB"     from="Muscle"       to="Tendon-Top-B"/>
  </coupling-scheme:multi>
</precice-configuration>